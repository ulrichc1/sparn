/**
 * Docs Generator - Auto-generate CLAUDE.md
 *
 * Scans repo structure, uses dependency graph data, and generates
 * a compact CLAUDE.md optimized for AI agent context loading.
 */

import { existsSync, readdirSync, readFileSync } from 'node:fs';
import { extname, join, relative } from 'node:path';
import type { DependencyGraph, GraphAnalysis } from './dependency-graph.js';

export interface DocsGeneratorConfig {
  projectRoot: string;
  /** Include dependency graph summary */
  includeGraph?: boolean;
  /** Include debt tracker info */
  includeDebt?: boolean;
  /** Custom sections to append */
  customSections?: string[];
}

export interface DocsGenerator {
  /** Generate CLAUDE.md content */
  generate(graph?: DependencyGraph): Promise<string>;
}

/**
 * Detect entry points by looking for common patterns
 */
function detectEntryPoints(projectRoot: string): Array<{ path: string; description: string }> {
  const entries: Array<{ path: string; description: string }> = [];
  const candidates = [
    { path: 'src/index.ts', desc: 'Library API' },
    { path: 'src/cli/index.ts', desc: 'CLI entry point' },
    { path: 'src/daemon/index.ts', desc: 'Daemon process' },
    { path: 'src/mcp/index.ts', desc: 'MCP server' },
    { path: 'src/main.ts', desc: 'Main entry' },
    { path: 'src/app.ts', desc: 'App entry' },
    { path: 'src/server.ts', desc: 'Server entry' },
    { path: 'index.ts', desc: 'Root entry' },
    { path: 'index.js', desc: 'Root entry' },
  ];

  for (const c of candidates) {
    if (existsSync(join(projectRoot, c.path))) {
      entries.push({ path: c.path, description: c.desc });
    }
  }

  return entries;
}

/**
 * Scan directory structure for module summary
 */
function scanModules(
  dir: string,
  projectRoot: string,
  ignoreDirs = ['node_modules', 'dist', '.git', '.sparn', 'coverage'],
): Array<{ path: string; lines: number }> {
  const modules: Array<{ path: string; lines: number }> = [];

  try {
    const entries = readdirSync(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = join(dir, entry.name);

      if (entry.isDirectory() && !ignoreDirs.includes(entry.name)) {
        modules.push(...scanModules(fullPath, projectRoot, ignoreDirs));
      } else if (entry.isFile() && ['.ts', '.tsx', '.js', '.jsx'].includes(extname(entry.name))) {
        try {
          const content = readFileSync(fullPath, 'utf-8');
          modules.push({
            path: relative(projectRoot, fullPath).replace(/\\/g, '/'),
            lines: content.split('\n').length,
          });
        } catch {
          // Skip
        }
      }
    }
  } catch {
    // Skip
  }

  return modules;
}

/**
 * Read package.json for project info
 */
function readPackageJson(
  projectRoot: string,
): { name: string; version: string; scripts: Record<string, string> } | null {
  const pkgPath = join(projectRoot, 'package.json');
  if (!existsSync(pkgPath)) return null;

  try {
    return JSON.parse(readFileSync(pkgPath, 'utf-8'));
  } catch {
    return null;
  }
}

/**
 * Detect tech stack from dependencies
 */
function detectStack(projectRoot: string): string[] {
  const stack: string[] = [];
  const pkg = readPackageJson(projectRoot);
  if (!pkg) return stack;

  const allDeps = {
    ...(pkg as unknown as { dependencies?: Record<string, string> }).dependencies,
    ...(pkg as unknown as { devDependencies?: Record<string, string> }).devDependencies,
  };

  if (allDeps['typescript']) stack.push('TypeScript');
  if (allDeps['vitest']) stack.push('Vitest');
  if (allDeps['@biomejs/biome']) stack.push('Biome');
  if (allDeps['eslint']) stack.push('ESLint');
  if (allDeps['prettier']) stack.push('Prettier');
  if (allDeps['react']) stack.push('React');
  if (allDeps['next']) stack.push('Next.js');
  if (allDeps['express']) stack.push('Express');
  if (allDeps['commander']) stack.push('Commander.js CLI');
  if (allDeps['better-sqlite3']) stack.push('SQLite (better-sqlite3)');
  if (allDeps['zod']) stack.push('Zod validation');

  return stack;
}

/**
 * Create a docs generator
 */
export function createDocsGenerator(config: DocsGeneratorConfig): DocsGenerator {
  const { projectRoot, includeGraph = true } = config;

  async function generate(graph?: DependencyGraph): Promise<string> {
    const lines: string[] = [];
    const pkg = readPackageJson(projectRoot);
    const projectName = pkg?.name || 'Project';
    const now = new Date().toISOString();

    // Header
    lines.push(`# ${projectName} — Developer Guide`);
    lines.push(`<!-- Auto-generated by Sparn v1.3.0 — ${now} -->`);
    lines.push('');

    // Tech stack
    const stack = detectStack(projectRoot);
    if (stack.length > 0) {
      lines.push(`**Stack**: ${stack.join(', ')}`);
      lines.push('');
    }

    // Commands
    if (pkg?.scripts) {
      lines.push('## Commands');
      lines.push('');
      const important = ['build', 'dev', 'test', 'lint', 'typecheck', 'start'];
      for (const cmd of important) {
        if (pkg.scripts[cmd]) {
          lines.push(`- \`npm run ${cmd}\` — \`${pkg.scripts[cmd]}\``);
        }
      }
      lines.push('');
    }

    // Entry points
    const entryPoints = detectEntryPoints(projectRoot);
    if (entryPoints.length > 0) {
      lines.push('## Entry Points');
      lines.push('');
      for (const ep of entryPoints) {
        lines.push(`- \`${ep.path}\` — ${ep.description}`);
      }
      lines.push('');
    }

    // Module summary
    const srcDir = join(projectRoot, 'src');
    if (existsSync(srcDir)) {
      const modules = scanModules(srcDir, projectRoot);

      // Group by directory
      const dirGroups = new Map<string, Array<{ file: string; lines: number }>>();
      for (const mod of modules) {
        const parts = mod.path.split('/');
        const dir = parts.length > 2 ? parts.slice(0, 2).join('/') : parts[0] || '';
        if (!dirGroups.has(dir)) {
          dirGroups.set(dir, []);
        }
        dirGroups.get(dir)?.push({
          file: parts[parts.length - 1] || mod.path,
          lines: mod.lines,
        });
      }

      lines.push('## Structure');
      lines.push('');
      for (const [dir, files] of dirGroups) {
        lines.push(`### ${dir}/ (${files.length} files)`);
        // Show up to 8 files per dir
        const shown = files.slice(0, 8);
        for (const f of shown) {
          lines.push(`- \`${f.file}\` (${f.lines}L)`);
        }
        if (files.length > 8) {
          lines.push(`- ... and ${files.length - 8} more`);
        }
        lines.push('');
      }
    }

    // Dependency graph analysis
    if (includeGraph && graph) {
      try {
        const analysis: GraphAnalysis = await graph.analyze();

        lines.push('## Hot Dependencies (most imported)');
        lines.push('');
        for (const path of analysis.hotPaths.slice(0, 5)) {
          const node = graph.getNodes().get(path);
          const callerCount = node?.callers.length || 0;
          lines.push(`- \`${path}\` (imported by ${callerCount} modules)`);
        }
        lines.push('');

        if (analysis.orphans.length > 0) {
          lines.push(
            `**Orphaned files** (${analysis.orphans.length}): ${analysis.orphans.slice(0, 3).join(', ')}${analysis.orphans.length > 3 ? '...' : ''}`,
          );
          lines.push('');
        }

        lines.push(
          `**Total tokens**: ${analysis.totalTokens.toLocaleString()} | **Hot path tokens**: ${analysis.optimizedTokens.toLocaleString()}`,
        );
        lines.push('');
      } catch {
        // Skip graph section on error
      }
    }

    // Sparn config
    const sparnConfigPath = join(projectRoot, '.sparn', 'config.yaml');
    if (existsSync(sparnConfigPath)) {
      lines.push('## Sparn Optimization');
      lines.push('');
      lines.push('Sparn is active in this project. Key features:');
      lines.push('- Context optimization (60-70% token reduction)');
      lines.push('- Use `sparn search` before reading files');
      lines.push('- Use `sparn graph` to understand dependencies');
      lines.push('- Use `sparn plan` for planning, `sparn exec` for execution');
      lines.push('');
    }

    // Custom sections
    if (config.customSections) {
      for (const section of config.customSections) {
        lines.push(section);
        lines.push('');
      }
    }

    return lines.join('\n');
  }

  return { generate };
}
